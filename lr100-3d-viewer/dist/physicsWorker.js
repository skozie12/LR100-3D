import{a as m,B as b,V as A,S as at,D as k,b as ht,Q as Rt,W as wt,M as zt,C as Pt}from"./cannon-es.js";let d,v;const I={COILER:1,ROPE:2,ROPE_SEGMENT:4,ANCHOR:8};let It=0,vt=0,Ft=0;const j=1/60,Mt=8,ft=60,U=56,St=.012,rt=.15,J=.006;let a=[],g,T,S,l,z,P;const B=13;let Y=0,tt=1,D=0,R=!1,G=400,W=0,F=new Set,N=0,h=null,u="100-10";const Dt={"100-10":Math.PI/18.9,"100-99":Math.PI/15.498,"100-200":Math.PI/10.505},Tt=40,X=.04;let bt=!0,At=new Map,q=0,C=0,Q=new Map,Bt=[],et=[],ot=200,it=5e4;const nt=.9,kt=.05,Ct=60;let $=0,O=!1;const gt=5,ut=10;let yt=0,Z=!0,K=!0;function $t(){d=new wt({gravity:new A(0,-9.81,0)}),v=new zt("defaultMaterial"),d.defaultContactMaterial=new Pt(v,v,{friction:.8,restitution:.01,contactEquationStiffness:5e5,contactEquationRelaxation:5,frictionEquationStiffness:5e5*1.5,frictionEquationRelaxation:5}),d.defaultMaterial=v,g=new b({mass:0}),g.position.set(.57,.225+.2,.025),g.type=m.KINEMATIC,d.addBody(g),T=new b({mass:0}),T.position.set(-.6,.27,-.058),T.type=m.STATIC,d.addBody(T),S=new b({mass:0}),S.position.set(0,.3,.03),S.type=m.STATIC,d.addBody(S),F=new Set}function ct(){if(!l||!g)return;const i=h==null?void 0:h[u];if(!i)return;const e=i.radius;g.position.x=l.position.x,g.position.y=l.position.y+e+kt,g.position.z=l.position.z,console.log(`Positioned end anchor at top of coiler: (${g.position.x.toFixed(3)}, ${g.position.y.toFixed(3)}, ${g.position.z.toFixed(3)})`)}function Ot(){st(),ct();for(let n=0;n<U;n++){const o=new at(St/2);let s,c,r;if(n<=B){const p=n/B;s=T.position.x+p*(S.position.x-T.position.x),c=T.position.y+p*(S.position.y-T.position.y),r=T.position.z+p*(S.position.z-T.position.z),c+=Math.sin(p*Math.PI)*.05}else{const p=(n-B)/(U-B-1);s=S.position.x+p*(g.position.x-S.position.x);const M=Math.sin(p*Math.PI)*.15;c=S.position.y+p*(g.position.y-S.position.y)+M,r=S.position.z+p*(g.position.z-g.position.z)}const f=new b({mass:rt,shape:o,position:new A(s,c,r),material:v,collisionFilterGroup:I.ROPE|I.ROPE_SEGMENT,collisionFilterMask:I.COILER|I.ROPE_SEGMENT});f.type=m.DYNAMIC,f.angularDamping=.99,f.linearDamping=.99,d.addBody(f),a.push(f)}for(let n=0;n<U-1;n++){const o=new k(a[n],a[n+1],J*nt,it);o.collideConnected=!1,o.maxForce=ot,d.addConstraint(o)}const i=new k(S,a[B],0);d.addConstraint(i);const e=new k(T,a[0],0);d.addConstraint(e);const t=new k(g,a[U-1],0);d.addConstraint(t)}function Vt(){for(let i=0;i<a.length;i++){const e=a[i];if(!e||e.type===m.STATIC)continue;const t=e.velocity.length();t>gt&&e.velocity.scale(gt/t);const n=e.angularVelocity.length();n>ut&&e.angularVelocity.scale(ut/n)}}function st(i=!1){var e;try{R=!1,N=0,q=0,C=0,Q?Q.clear():Q=new Map,At.clear();for(let t=((e=d==null?void 0:d.constraints)==null?void 0:e.length)-1;t>=0;t--)d.constraints[t]instanceof k&&d.removeConstraint(d.constraints[t]);for(let t=0;t<a.length;t++)d.removeBody(a[t]);a.length=0,Y=0,tt=1,D=0,It=0,vt=0,i&&(Ft=0,W=0),Bt=[],F.clear(),et=[],H()}catch(t){console.error("Error in resetRope:",t)}}function _t(i,e,t,n,o){const s=j,c=Mt;q+=s,N++;let r=n;O&&($--,$<=0?(O=!1,console.log("Delay complete - starting coiler rotation")):r=0);const f=r*s;C===void 0&&(C=0),C+=f;for(let M=0;M<c;M++)d.step(s/c),Vt();Nt(r),qt(),xt(f);const p=Dt[u]||Math.PI/12;return Math.abs(C-W)>=p&&Et(h,u,t,C)&&(W=C,console.log(`Added segment for ${u} at angle: ${C.toFixed(3)} radians (${(C*180/Math.PI).toFixed(1)}Â°), increment: ${p.toFixed(4)}`)),{positions:_(),segmentCount:a.length,staticCount:F.size,simulationTime:q,rotationAngle:C,delayActive:O,delayRemaining:$}}function H(i=Ct){$=i,O=!0,console.log(`Setting startup delay: ${i} frames`)}function Nt(i){if(!l||R)return;const e=h==null?void 0:h[u];if(!e)return;const t=e.radius,n=l.position,o=Math.sign(i);for(let s=0;s<a.length;s++){const c=a[s];if(!c||c.type===m.STATIC)continue;const r=n.x-c.position.x,f=n.y-c.position.y,p=Math.sqrt(r*r+f*f),M=t*4;if(p>M)continue;const w=r/p,E=f/p,y=-E,x=w,L=t+.01,V=p-L,lt=Math.min(1,Math.max(0,1-Math.abs(V)/M)),pt=V*20*lt;c.applyForce(new A(w*pt,E*pt,0),new A(0,0,0));const dt=Math.abs(i)*10*lt;c.applyForce(new A(y*dt*o,x*dt*o,0),new A(0,0,0)),Math.abs(V)<.1&&(c.velocity.scale(.75),c.angularVelocity.scale(.75))}}function qt(){if(!l||R)return;if(N<ft){N%10===0&&console.log(`Waiting ${ft-N} more frames before allowing static conversion`),Lt();return}const i=h==null?void 0:h[u];if(!i)return;const e=i.radius,t=l.position;N%60===0&&console.log(`Current static segments: ${F.size}/${a.length}`);for(let n=0;n<a.length;n++){const o=a[n];if(!o||o.type===m.STATIC||n===0||n===B)continue;const s=o.position.x-t.x,c=o.position.y-t.y,r=Math.sqrt(s*s+c*c),f=Math.abs(r-e);if(f<X){et[n]||(et[n]={pos:{x:o.position.x,y:o.position.y,z:o.position.z}},console.log(`Segment ${n} near coiler, dist: ${f.toFixed(4)}`));const p=s/r,M=c/r,E=r-e;let y=2;f>X*.5&&(y=4);const x=E*Tt*y*.8;o.applyForce(new A(p*x,M*x,0),new A(0,0,0)),o.velocity.scale(.7),o.angularVelocity.scale(.7),f<X*.25&&Yt(n)}}}function Lt(){if(!l)return;const i=h==null?void 0:h[u];if(!i)return;const e=i.radius,t=l.position;for(let n=0;n<a.length;n++){const o=a[n];if(!o||o.type===m.STATIC||n===0||n===B)continue;const s=o.position.x-t.x,c=o.position.y-t.y,r=Math.sqrt(s*s+c*c);if(Math.abs(r-e)<X*1.5){const p=s/r,M=c/r,y=(r-e)*Tt*.7;o.applyForce(new A(p*y,M*y,0),new A(0,0,0)),o.velocity.scale(.85),o.angularVelocity.scale(.85)}}}function Yt(i){const e=a[i];if(!e||e.type===m.STATIC)return!1;try{const t=e.position.x-l.position.x,n=e.position.y-l.position.y,o=Math.atan2(n,t),s=h==null?void 0:h[u],c=(s==null?void 0:s.radius)||.18;return e.position.x=l.position.x+c*Math.cos(o),e.position.y=l.position.y+c*Math.sin(o),e.type=m.STATIC,e.mass=0,e.updateMassProperties(),e.velocity.set(0,0,0),e.angularVelocity.set(0,0,0),e.force.set(0,0,0),e.torque.set(0,0,0),e.userData={coilerAttachment:{angle:o,radius:c,z:e.position.z-l.position.z}},F.add(i),bt&&console.log(`Segment ${i} static at (${e.position.x.toFixed(3)}, ${e.position.y.toFixed(3)}), exactly on coiler surface`),!0}catch(t){return console.error(`Error making segment ${i} static:`,t),!1}}function xt(i){var t;if(!l||i===0)return;const e=i*.95;for(let n=0;n<a.length;n++){const o=a[n];if(!o||o.type!==m.STATIC||!((t=o.userData)!=null&&t.coilerAttachment))continue;const s=o.userData.coilerAttachment;s.angle+=e,o.position.x=l.position.x+s.radius*Math.cos(s.angle),o.position.y=l.position.y+s.radius*Math.sin(s.angle),o.position.z=l.position.z+s.z}}function Et(i,e,t,n){const o=t||(e==="100-200"?300:400);if(a.length>=o||a.length<22)return!1;try{const s=a[20],c=a[21];if(!s||!c)return!1;const r=new b({mass:rt,shape:new at(St/2),position:new A(s.position.x,s.position.y,s.position.z),material:v,collisionFilterGroup:I.ROPE|I.ROPE_SEGMENT,collisionFilterMask:I.COILER|I.ROPE_SEGMENT});r.type=m.DYNAMIC;const f=Y;if(At.set(r.id,f),r.userData={creationAngle:n,creationTime:q||0,creationIndex:f},Y++,l){const y=l.position.x-s.position.x,x=l.position.y-s.position.y,V=Math.sqrt(y*y+x*x)>.5?1.2:.8;r.velocity.set(y*V,x*V,0)}r.linearDamping=.95,r.angularDamping=.95,d.addBody(r),d.constraints.forEach(y=>{(y.bodyA===s&&y.bodyB===c||y.bodyA===c&&y.bodyB===s)&&d.removeConstraint(y)}),Y%30===0&&(tt*=-1),D||(D=0);const p=i[e];if(p){const y=(p.sideOffset1-p.sideOffset2)*.8,x=Math.sin(n*.5)*.3;D+=tt*(y/50)*.9,D+=x*.01;const L=y*.45;D=Math.max(Math.min(D,L),-L),r.position.z+=D*.3}const M=a.slice(21);a.length=21,a.push(r),a.push(...M);const w=new k(s,r,J*nt,it),E=new k(r,a[22],J*nt,it);return w.collideConnected=!1,E.collideConnected=!1,w.maxForce=ot,E.maxForce=ot,d.addConstraint(w),d.addConstraint(E),console.log(`Created segment with index ${Y}`),!0}catch(s){return console.error("Error adding segment:",s),!1}}function mt(){R=!0,console.log("Finalizing rope - making ALL segments static");for(let i=0;i<a.length;i++){const e=a[i];if(e){if(e.type=m.STATIC,e.mass=0,e.updateMassProperties(),e.velocity.set(0,0,0),e.angularVelocity.set(0,0,0),e.force.set(0,0,0),e.torque.set(0,0,0),l){const t=e.position.x-l.position.x,n=e.position.y-l.position.y,o=Math.sqrt(t*t+n*n);if(o<l.shapes[0].radius*2){const s=Math.atan2(n,t);e.userData={coilerAttachment:{angle:s,radius:o,z:e.position.z-l.position.z}}}}F.add(i)}}g&&(g.type=m.STATIC,g.updateMassProperties()),T&&(T.type=m.STATIC,T.updateMassProperties()),S&&(S.type=m.STATIC,S.updateMassProperties()),console.log(`Finalized rope with ${F.size} static segments out of ${a.length} total`)}function Ht(i,e,t){if(!g)return;g.position.set(i,e,t),g.velocity.set(0,0,0),g.angularVelocity.set(0,0,0);const n=Math.min(10,a.length);for(let o=a.length-n;o<a.length;o++)a[o]&&(a[o].velocity.scale(.9),a[o].angularVelocity.scale(.9))}function Wt(i){l&&(l.angularVelocity.set(0,0,i),z&&z.angularVelocity.set(0,0,i),P&&P.angularVelocity.set(0,0,i))}function Ut(i,e){const t=e&&u!==e;h=i,u=e||u,t&&(C=0,W=0,console.log(`Coiler type changed to ${u}, reset angle tracking`),H());const n=i[u];if(!n)return console.error("Invalid coiler type:",u),null;const o=n.radius,s=n.height;l&&d.removeBody(l),l=new b({mass:0,type:m.KINEMATIC,material:v,collisionFilterGroup:I.COILER,collisionFilterMask:I.ROPE});const c=new ht(o,o,s,16);l.addShape(c,new A(0,0,0),new Rt().setFromAxisAngle(new A(1,0,0),Math.PI/2));const r=o*.03,f=6;for(let p=0;p<32;p++){const M=p/32*Math.PI*2*f,w=p/32*s-s/2,E=o*.97*Math.cos(M),y=o*.97*Math.sin(M),x=new at(r);l.addShape(x,new A(E,y,w))}return l.position.set(.57,.225,n.zOffset),d.addBody(l),ct(),l}function Gt(i,e){z&&(d.removeBody(z),z=null),P&&(d.removeBody(P),P=null);const t=i[u];if(!t)return null;const n=t.radius,o=t.height,s=u==="100-10"?2:u==="100-99"?2.1:2.2,c=new ht(n*s,n*s,o/10,16);return z=new b({mass:0,type:m.KINEMATIC,shape:c,material:v}),z.position.set(.57,.225,t.sideOffset1),z.quaternion.setFromEuler(Math.PI/2,0,0),d.addBody(z),P=new b({mass:0,type:m.KINEMATIC,shape:c,material:v}),P.position.set(.57,.225,t.sideOffset2),P.quaternion.setFromEuler(Math.PI/2,0,0),d.addBody(P),{side1:z,side2:P}}function _(){return a.map(i=>!i||!i.position?null:{x:i.position.x,y:i.position.y,z:i.position.z}).filter(i=>i!==null)}self.onmessage=function(i){try{const{type:e,data:t}=i.data;switch(e){case"init":$t(),Z=!0,K=!0,R=!1,H(),self.postMessage({type:"initialized",delayActive:O,delayRemaining:$}),setTimeout(()=>{Z=!1,console.log("Worker initialization complete - rope is ready for normal operation")},500);break;case"resetRope":q=0,C=0,W=0,R=!1,K=!0,st(t==null?void 0:t.resetAngle),self.postMessage({type:"ropeReset"});break;case"createCoiler":h=t.coilerConfig;const n=u!==t.activeCoilerType;u=t.activeCoilerType,G=u==="100-200"?300:400,n&&(console.log(`Coiler type changed from ${u} to ${t.activeCoilerType}, resetting rope`),st(!0),R=!1),Ut(t.coilerConfig,t.activeCoilerType),Gt(t.coilerConfig,t.activeCoilerType),ct(),self.postMessage({type:"coilerCreated",coilerType:u,maxSegments:G});break;case"createRope":Ot(),R=!1,H();for(let r=0;r<a.length;r++)a[r]&&(a[r].type=m.DYNAMIC,a[r].mass===0&&(a[r].mass=rt,a[r].updateMassProperties()));F.clear();const o=_();console.log("Rope created with "+a.length+" dynamic segments"),self.postMessage({type:"ropeCreated",positions:o,delayActive:O,delayRemaining:$}),K=!1;break;case"step":if(!Z&&!K&&t.rotationSpeed===0&&yt!==0&&!R&&(console.log("Detected coiler stopped rotating - immediately finalizing rope"),mt(),self.postMessage({type:"ropeFinalized",positions:_()})),yt=t.rotationSpeed,R){t.rotationSpeed!==0&&xt(t.rotationSpeed*j),self.postMessage({type:"stepped",positions:_(),count:a.length,staticCount:F.size,simulationTime:q,delayActive:!1,ropeFinalized:!0});break}const s=_t(j,Mt,G,t.rotationSpeed,t.rotationAngle);self.postMessage({type:"stepped",positions:s.positions,count:s.segmentCount,staticCount:s.staticCount,simulationTime:s.simulationTime,rotationAngle:s.rotationAngle,delayActive:s.delayActive,delayRemaining:s.delayRemaining,ropeFinalized:R});break;case"updateAnchor":Ht(t.x,t.y,t.z);break;case"setRotation":Wt(t.rotationSpeed);break;case"finalizeRope":mt(),self.postMessage({type:"ropeFinalized",positions:_()});break;case"setDelay":H(t.frames||Ct),self.postMessage({type:"delaySet",delayActive:O,delayRemaining:$});break;case"addSegment":Et(t.coilerConfig||h,t.activeCoilerType||u,t.maxSegments||G,t.rotationAngle||C)&&self.postMessage({type:"segmentAdded",positions:_(),count:a.length});break;default:console.warn(`Unknown message type: ${e}`);break}}catch(e){console.error("Worker error:",e),self.postMessage({type:"error",error:e.toString()})}};
